import { NextRequest, NextResponse } from 'next/server'
import Anthropic from '@anthropic-ai/sdk'

// Initialize Anthropic client
const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY || '',
})

// Validate API key exists
if (!process.env.ANTHROPIC_API_KEY) {
  console.error(‚ö†Ô∏è ANTHROPIC_API_KEY is not set in environment variables')
}

// ============================================
// REGIONAL DATA SYSTEM (Inline for simplicity)
// ============================================

interface Holiday {
  date: string;
  name: string;
  description: string;
  type: 'public' | 'cultural' | 'religious' | 'seasonal';
  relevance: 'high' | 'medium' | 'low';
}

interface RegionalConfig {
  country: string;
  countryCode: string;
  language: string;
  holidays: Holiday[];
  culturalNotes: string[];
  terminology: { [key: string]: string };
}

// UK Configuration
const UK_CONFIG: RegionalConfig = {
  country: 'United Kingdom',
  countryCode: 'GB',
  language: 'British English',
  terminology: {
    holiday: 'vacation',
    fall: 'autumn',
    vacation: 'holiday',
  },
  culturalNotes: [
    'Bank holidays are important public holidays',
    'Christmas period is significant (24-26 Dec)',
    'Boxing Day (26 Dec) is a major shopping and relaxation day',
    'Guy Fawkes Night (5 Nov) is culturally significant',
    'August is traditionally "holiday season" when many take vacations',
  ],
  holidays: [
    { date: '2025-01-01', name: "New Year's Day", description: 'Start of the new year', type: 'public', relevance: 'high' },
    { date: '2025-04-18', name: 'Good Friday', description: 'Easter religious observance', type: 'public', relevance: 'high' },
    { date: '2025-04-21', name: 'Easter Monday', description: 'Easter bank holiday', type: 'public', relevance: 'high' },
    { date: '2025-05-05', name: 'Early May Bank Holiday', description: 'Spring bank holiday', type: 'public', relevance: 'high' },
    { date: '2025-05-26', name: 'Spring Bank Holiday', description: 'Late spring bank holiday', type: 'public', relevance: 'high' },
    { date: '2025-08-25', name: 'Summer Bank Holiday', description: 'End of summer holiday', type: 'public', relevance: 'high' },
    { date: '2025-10-31', name: 'Halloween', description: 'Spooky celebrations', type: 'cultural', relevance: 'high' },
    { date: '2025-11-05', name: 'Guy Fawkes Night', description: 'Bonfire Night celebrations', type: 'cultural', relevance: 'high' },
    { date: '2025-12-24', name: 'Christmas Eve', description: 'Day before Christmas', type: 'cultural', relevance: 'high' },
    { date: '2025-12-25', name: 'Christmas Day', description: 'Major Christian holiday', type: 'public', relevance: 'high' },
    { date: '2025-12-26', name: 'Boxing Day', description: 'Day after Christmas', type: 'public', relevance: 'high' },
    { date: '2025-12-31', name: "New Year's Eve", description: 'End of year celebration', type: 'cultural', relevance: 'high' },
  ],
};

// US Configuration
const US_CONFIG: RegionalConfig = {
  country: 'United States',
  countryCode: 'US',
  language: 'American English',
  terminology: {
    holiday: 'holiday',
    fall: 'fall',
    vacation: 'vacation',
  },
  culturalNotes: [
    'Thanksgiving (4th Thursday in November) is major family holiday',
    'July 4th is Independence Day - major celebration',
    'Black Friday/Cyber Monday are huge shopping events',
    'Halloween is major celebration for all ages',
  ],
  holidays: [
    { date: '2025-01-01', name: "New Year's Day", description: 'Start of the new year', type: 'public', relevance: 'high' },
    { date: '2025-02-14', name: "Valentine's Day", description: 'Romantic celebration', type: 'cultural', relevance: 'high' },
    { date: '2025-04-20', name: 'Easter Sunday', description: 'Christian holiday', type: 'religious', relevance: 'high' },
    { date: '2025-05-11', name: "Mother's Day", description: 'Honoring mothers', type: 'cultural', relevance: 'high' },
    { date: '2025-07-04', name: 'Independence Day', description: 'US national holiday', type: 'public', relevance: 'high' },
    { date: '2025-10-31', name: 'Halloween', description: 'Spooky celebrations', type: 'cultural', relevance: 'high' },
    { date: '2025-11-27', name: 'Thanksgiving', description: 'Major family holiday with turkey dinner', type: 'public', relevance: 'high' },
    { date: '2025-11-28', name: 'Black Friday', description: 'Major shopping day', type: 'cultural', relevance: 'high' },
    { date: '2025-12-25', name: 'Christmas Day', description: 'Major Christian holiday', type: 'public', relevance: 'high' },
  ],
};

const REGIONAL_CONFIGS: { [key: string]: RegionalConfig } = {
  GB: UK_CONFIG,
  UK: UK_CONFIG,
  US: US_CONFIG,
  USA: US_CONFIG,
};

function getRegionalConfig(countryCode: string): RegionalConfig {
  const code = countryCode.toUpperCase();
  return REGIONAL_CONFIGS[code] || US_CONFIG;
}

function getHolidaysForMonth(countryCode: string, year: number, month: number): Holiday[] {
  const config = getRegionalConfig(countryCode);
  const monthStr = month.toString().padStart(2, '0');
  const datePrefix = `${year}-${monthStr}`;
  
  return config.holidays.filter(holiday => holiday.date.startsWith(datePrefix));
}

function generateRegionalPromptContext(
  targetCountryCode: string,
  month: number,
  customEvents?: Array<{ date: string; name: string; description: string }>
): string {
  const targetConfig = getRegionalConfig(targetCountryCode);
  const currentYear = new Date().getFullYear();
  const monthHolidays = getHolidaysForMonth(targetCountryCode, currentYear, month);
  
  let context = `
REGIONAL CONTEXT:

Target Audience: ${targetConfig.country} (${targetConfig.countryCode})
- Create content relevant to ${targetConfig.country} culture
- Use ${targetConfig.language} spelling and terminology

HOLIDAYS & EVENTS THIS MONTH:
${monthHolidays.map(h => `- ${h.name} (${h.date}): ${h.description}`).join('\n')}
${monthHolidays.length === 0 ? '- No major holidays this month' : ''}

${customEvents && customEvents.length > 0 ? `
CUSTOM EVENTS:
${customEvents.map(e => `- ${e.name} (${e.date}): ${e.description}`).join('\n')}
` : ''}

CULTURAL NOTES FOR ${targetConfig.country}:
${targetConfig.culturalNotes.slice(0, 5).map(note => `- ${note}`).join('\n')}

CRITICAL INSTRUCTIONS:
- DO NOT mention holidays that don't apply to ${targetConfig.country}
- Use ${targetConfig.country}-appropriate cultural references
- When saying "holiday" in ${targetConfig.country}, it means "${targetConfig.terminology.holiday}"
`;
  
  return context;
}

// ============================================
// DEDUPLICATION LOGIC
// ============================================

function calculateSimilarity(str1: string, str2: string): number {
  const longer = str1.length > str2.length ? str1 : str2;
  const shorter = str1.length > str2.length ? str2 : str1;
  
  if (longer.length === 0) return 1.0;
  
  const distance = levenshteinDistance(longer, shorter);
  return (longer.length - distance) / longer.length;
}

function levenshteinDistance(str1: string, str2: string): number {
  const matrix: number[][] = [];
  
  for (let i = 0; i <= str2.length; i++) {
    matrix[i] = [i];
  }
  
  for (let j = 0; j <= str1.length; j++) {
    matrix[0][j] = j;
  }
  
  for (let i = 1; i <= str2.length; i++) {
    for (let j = 1; j <= str1.length; j++) {
      if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j - 1] + 1,
          matrix[i][j - 1] + 1,
          matrix[i - 1][j] + 1
        );
      }
    }
  }
  
  return matrix[str2.length][str1.length];
}

function validateAndDeduplicateTopics(newTopics: any[], existingTopics: string[]): any[] {
  const validated: any[] = [];
  const seenTitles = new Set(existingTopics.map(t => t.toLowerCase().trim()));
  
  for (const topic of newTopics) {
    if (!topic.title || !topic.hook) {
      console.warn('‚ö†Ô∏è Skipping invalid topic:', topic.title);
      continue;
    }
    
    const normalizedTitle = topic.title.toLowerCase().trim();
    
    if (seenTitles.has(normalizedTitle)) {
      console.warn('‚ö†Ô∏è Skipping duplicate topic:', topic.title);
      continue;
    }
    
    const isTooSimilar = Array.from(seenTitles).some(existing => {
      return calculateSimilarity(normalizedTitle, existing) > 0.75; // 75% similar = duplicate
    });
    
    if (isTooSimilar) {
      console.warn('‚ö†Ô∏è Skipping similar topic:', topic.title);
      continue;
    }
    
    validated.push(topic);
    seenTitles.add(normalizedTitle);
  }
  
  return validated;
}

// ============================================
// HELPER FUNCTIONS
// ============================================

function parseAIResponse(responseText: string): any[] {
  try {
    const jsonMatch = responseText.match(/```json\s*([\s\S]*?)\s*```/)
    if (jsonMatch) {
      return JSON.parse(jsonMatch[1].trim())
    }
    
    const arrayMatch = responseText.match(/\[[\s\S]*\]/)
    if (arrayMatch) {
      return JSON.parse(arrayMatch[0])
    }
    
    return JSON.parse(responseText)
  } catch (error) {
    console.error('Failed to parse AI response:', responseText)
    throw new Error('Could not parse AI response as JSON')
  }
}

// ============================================
// MAIN API ROUTE
// ============================================

export async function POST(request: NextRequest) {
  try {
    if (!process.env.ANTHROPIC_API_KEY) {
      return NextResponse.json(
        { 
          error: 'Server configuration error',
          details: 'ANTHROPIC_API_KEY is not configured.'
        },
        { status: 500 }
      )
    }

    const body = await request.json()
    // Accept both 'regional' and 'regionalSettings' for backward compatibility
const { userProfile, projectConfig, regional, regionalSettings, existingTopics = [] } = body
const settings = regionalSettings || regional || {}

    if (!userProfile || !projectConfig) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      )
    }

    const { videosNeeded } = projectConfig
    
    if (!videosNeeded || videosNeeded < 1) {
      return NextResponse.json(
        { error: 'videosNeeded must be at least 1' },
        { status: 400 }
      )
    }

    // Extract regional settings (default to GB if not provided)
   const creatorCountry = settings?.creatorCountry || 'GB';
const targetCountry = settings?.targetCountry || creatorCountry;
    
    // Parse month for regional context
    const [year, month] = (projectConfig.month || '2025-01').split('-').map(Number);
    
    // Generate regional context
    const regionalContext = generateRegionalPromptContext(
      targetCountry,
      month,
      projectConfig.customEvents
    );

    console.log(`üé¨ Generating ${videosNeeded} topics for ${userProfile.channelName}`)
    console.log(`üåç Regional context: Creator=${creatorCountry}, Target=${targetCountry}, Month=${month}`)

    const allTopics: any[] = []
    const batchSize = 10
    const numBatches = Math.ceil(videosNeeded / batchSize)

    for (let i = 0; i < numBatches; i++) {
      const remainingTopics = videosNeeded - allTopics.length
      const topicsToGenerate = Math.min(batchSize, remainingTopics)
      
      console.log(`  Batch ${i + 1}/${numBatches}: Generating ${topicsToGenerate} topics...`)
      
      const prompt = `You are an expert YouTube Shorts content strategist.

${regionalContext}

CREATOR PROFILE:
Name: ${userProfile.name}
Channel: ${userProfile.channelName}
Niche: ${userProfile.niche}
Unique Angle: ${userProfile.uniqueAngle}

VOICE & TONE:
Primary Tone (60%): ${userProfile.primaryTone}
Secondary Tone (25%): ${userProfile.secondaryTone}
Accent Tone (15%): ${userProfile.accentTone}

PROJECT DETAILS:
Month: ${projectConfig.month}
Total Videos Needed: ${videosNeeded}

${existingTopics.length > 0 ? `
EXISTING TOPICS (DO NOT DUPLICATE):
${existingTopics.slice(-15).join('\n')}

CRITICAL: Generate UNIQUE topics that are DIFFERENT from the existing ones above.
` : ''}

${projectConfig.toneMix ? `TONE DISTRIBUTION:
${Object.entries(projectConfig.toneMix)
  .map(([tone, percentage]) => `- ${tone}: ${percentage}%`)
  .join('\n')}` : ''}

Generate exactly ${topicsToGenerate} YouTube Shorts topic ideas that:
1. ‚úÖ ARE relevant to ${targetCountry} audience
2. ‚úÖ REFERENCE ${targetCountry} holidays and cultural moments
3. ‚úÖ Are UNIQUE and DIFFERENT from each other
4. ‚ùå DO NOT reference holidays/events not celebrated in ${targetCountry}

Return exactly ${topicsToGenerate} topics with this structure:
[
  {
    "title": "Compelling topic title (max 100 chars)",
    "hook": "Attention-grabbing opening line",
    "coreValue": "What viewers will learn or feel",
    "emotionalDriver": "surprise|nostalgia|awe|curiosity|inspiration|relief",
    "formatType": "story|tutorial|list|challenge|myth-busting|behind-scenes",
    "tone": "${userProfile.primaryTone.toLowerCase()}",
    "longevity": "evergreen|seasonal|trending",
    "dateRangeStart": "${projectConfig.month}-01",
    "dateRangeEnd": "${projectConfig.month}-31",
    "factCheckStatus": "verified|needs_review|opinion",
    "orderIndex": ${allTopics.length + 1}
  }
]

IMPORTANT: Return ONLY valid JSON array. No text before or after.`

      try {
        const message = await anthropic.messages.create({
          model: 'claude-sonnet-4-20250514',
          max_tokens: 4000,
          temperature: 0.9,
          messages: [{ role: 'user', content: prompt }],
        })

        const responseText = message.content[0].type === 'text' ? message.content[0].text : ''
        const topicsBatch = parseAIResponse(responseText)
        
        if (!Array.isArray(topicsBatch)) {
          throw new Error('AI response was not an array')
        }

        // Deduplicate against all existing topics
        const deduplicatedBatch = validateAndDeduplicateTopics(
          topicsBatch,
          [...existingTopics, ...allTopics.map(t => t.title)]
        );

        allTopics.push(...deduplicatedBatch)
        console.log(`  ‚úÖ Batch ${i + 1} complete: ${deduplicatedBatch.length} unique topics generated`)
        
      } catch (batchError) {
        console.error(`‚ùå Error in batch ${i + 1}:`, batchError)
      }
    }

    if (allTopics.length === 0) {
      return NextResponse.json(
        { error: 'Failed to generate any topics. Please try again.' },
        { status: 500 }
      )
    }

    const finalTopics = allTopics.map((topic, index) => ({
      ...topic,
      id: `topic-${projectConfig.month}-${Date.now()}-${index}`,
      orderIndex: index + 1,
      createdAt: new Date().toISOString(),
    }))

    console.log(`‚úÖ Successfully generated ${finalTopics.length} unique topics`)

    return NextResponse.json({
      success: true,
      topics: finalTopics,
      message: `Generated ${finalTopics.length} topics successfully`,
      metadata: {
        requested: videosNeeded,
        generated: finalTopics.length,
        batches: numBatches,
        regional: {
          creator: creatorCountry,
          target: targetCountry,
          holidaysIncluded: getHolidaysForMonth(targetCountry, year, month).map(h => h.name),
        },
      }
    })
    
  } catch (error) {
    console.error('‚ùå Error generating topics:', error)
    
    let errorMessage = 'Failed to generate topics'
    let errorDetails = 'Unknown error'
    
    if (error instanceof Error) {
      errorDetails = error.message
      
      if (error.message.includes('API key')) {
        errorMessage = 'Invalid API key'
        errorDetails = 'Please check your ANTHROPIC_API_KEY environment variable'
      } else if (error.message.includes('rate limit')) {
        errorMessage = 'Rate limit exceeded'
        errorDetails = 'Please wait a moment and try again'
      }
    }

    return NextResponse.json(
      { success: false, error: errorMessage, details: errorDetails },
      { status: 500 }
    )
  }
}